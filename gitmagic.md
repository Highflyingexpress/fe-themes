- [Что такое GIT?](https://gitlab.com/levotarayan98/airways/-/wikis/%D0%9C%D0%B0%D0%B3%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B9-GIT#%D1%87%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-git)
- [Какие основные команды есть?](https://gitlab.com/levotarayan98/airways/-/wikis/%D0%9C%D0%B0%D0%B3%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B9-GIT#%D0%BA%D0%B0%D0%BA%D0%B8%D0%B5-%D0%BE%D1%81%D0%BD%D0%BE%D0%B2%D0%BD%D1%8B%D0%B5-%D0%BA%D0%BE%D0%BC%D0%B0%D0%BD%D0%B4%D1%8B-%D0%B5%D1%81%D1%82%D1%8C)
- [Что делать каждый день?](https://gitlab.com/levotarayan98/airways/-/wikis/%D0%9C%D0%B0%D0%B3%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B9-GIT#%D1%87%D1%82%D0%BE-%D0%B4%D0%B5%D0%BB%D0%B0%D1%82%D1%8C-%D0%BA%D0%B0%D0%B6%D0%B4%D1%8B%D0%B9-%D0%B4%D0%B5%D0%BD%D1%8C)

## **Что такое GIT?**

**GIT** - это система контроля версий, которая позволяет отслеживать изменения в коде и управлять ими. Она позволяет сохранять различные версии кода, возвращаться к предыдущим версиям и сравнивать их. Это очень полезный инструмент для разработчиков, которые работают над проектом в команде, так как он облегчает совместную работу и устраняет проблемы при слиянии изменений. Также GIT позволяет работать с различными ветками кода, что облегчает работу над разными задачами в различных частях проекта.

Плейлист для самостоятельного изучения - https://www.youtube.com/watch?v=W4hoc24K93E&list=PLDyvV36pndZFHXjXuwA_NywNrVQO0aQqb

## **Какие основные команды есть?**

Главные команды в GIT:

1. [`git init`](https://gitlab.com/levotarayan98/airways/-/wikis/%D0%9C%D0%B0%D0%B3%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B9-GIT#git-init) - создание нового репозитория GIT
2. [`git config`](https://gitlab.com/levotarayan98/airways/-/wikis/%D0%9C%D0%B0%D0%B3%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B9-GIT#git-config) - конфигурация вашего репозитория GIT
3. [`git add`](https://gitlab.com/levotarayan98/airways/-/wikis/%D0%9C%D0%B0%D0%B3%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B9-GIT#git-add) - добавление файлов в индекс для последующего коммита
4. [`git commit`](https://gitlab.com/levotarayan98/airways/-/wikis/%D0%9C%D0%B0%D0%B3%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B9-GIT#git-commit) - сохранение изменений в репозитории GIT
5. [`git clone`](https://gitlab.com/levotarayan98/airways/-/wikis/%D0%9C%D0%B0%D0%B3%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B9-GIT#git-clone) - создание локальной копии удаленного репозитория GIT
6. [`git remote`](https://gitlab.com/levotarayan98/airways/-/wikis/%D0%9C%D0%B0%D0%B3%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B9-GIT#git-remote) - управление удаленными репозиториями
7. [`git push`](https://gitlab.com/levotarayan98/airways/-/wikis/%D0%9C%D0%B0%D0%B3%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B9-GIT#git-push) - отправка изменений из локального репозитория на удаленный сервер GIT
8. [`git pull`](https://gitlab.com/levotarayan98/airways/-/wikis/%D0%9C%D0%B0%D0%B3%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B9-GIT#git-pull) - получение последних изменений из удаленного репозитория GIT
9. [`git branch`](https://gitlab.com/levotarayan98/airways/-/wikis/%D0%9C%D0%B0%D0%B3%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B9-GIT#git-branch) - создание, удаление веток
10. [`git checkout`](https://gitlab.com/levotarayan98/airways/-/wikis/%D0%9C%D0%B0%D0%B3%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B9-GIT#git-checkout) - переключение между ветками, для возврата к предыдущим версиям файлов или коммитов
11. [`git merge`](https://gitlab.com/levotarayan98/airways/-/wikis/%D0%9C%D0%B0%D0%B3%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B9-GIT#git-merge) - объединение изменений из одной ветки с другой
12. [`git rebase`](https://gitlab.com/levotarayan98/airways/-/wikis/%D0%9C%D0%B0%D0%B3%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B9-GIT#git-rebase) - перемещение коммитов в другую ветку oт изменения истории коммитов ветки
13. [`git diff`](https://gitlab.com/levotarayan98/airways/-/wikis/%D0%9C%D0%B0%D0%B3%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B9-GIT#git-diff) - просмотр различий между файлами и коммитами
14. [`git log`](https://gitlab.com/levotarayan98/airways/-/wikis/%D0%9C%D0%B0%D0%B3%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B9-GIT#git-log) - просмотр истории коммитов в репозитории GIT
15. [`git stash`](https://gitlab.com/levotarayan98/airways/-/wikis/%D0%9C%D0%B0%D0%B3%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B9-GIT#git-stash) - временное сохранение изменений в текущей ветке не делая индексирование
16. [`git reset`](https://gitlab.com/levotarayan98/airways/-/wikis/%D0%9C%D0%B0%D0%B3%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B9-GIT#git-reset) - отмена изменений в локальном репозитории GIT
17. [`git revert`](https://gitlab.com/levotarayan98/airways/-/wikis/%D0%9C%D0%B0%D0%B3%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B9-GIT#git-revert) - отмена определенных коммитов в репозитории GIT
18. [`git rerere`](https://gitlab.com/levotarayan98/airways/-/wikis/%D0%9C%D0%B0%D0%B3%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B9-GIT#git-rerere) - инструмент для автоматического разрешения конфликтов слияния

Это лишь небольшой список команд, но они являются основными инструментами для работы с GIT.

## **Что делать каждый день?**

- Перед тем как сесть за продолжение выполнения таски, подгрузите изменения с gitLab в вашу локальную ветку main. Если используете дополнительную локальную ветку для выполнения таски, то дополнительно сделайте для неё rebase
- Если сделали какие-то изменения в коде, отправьте коммиты в свою ветку на gitLab, не должно быть такой ситуации, что вы сделал сделали один коммит с полной выполненной задачей, где изменений на миллиард строк, которые будем разбирать командой несколько лет ;). Задача должна быть разбита на коммиты, а коммиты должны быть атомарными

## **Про каждую команду**

### **git init**

С этой командой вы уже скорее всего знакомы. Она создает локальный репозиторий GIT в выбранной вами папке.

### **git config**

**git config** используется для установки и просмотра конфигурационных настроек GIT. Некоторые из основных тегов, которые можно использовать с этой командой:

1. user.name: устанавливает имя пользователя для использования в коммитах<br/>
```git config --global user.name "Какое-то_имя"```
2. user.email: устанавливает email пользователя для использования в коммитах<br/>
```git config --global user.email "Какая-то_ваша_почта"```
3. git config --list: позволяет просмотреть все текущие настройки GIT на локальном уровне<br/>
```git config --list```

![image](uploads/72f942721f3010e485f2100ff71b13f6/image.png)

### **git add**

**git add** используется для добавления файлов в индекс GIT перед созданием коммита. Она позволяет отслеживать изменения файлов в вашем рабочем каталоге и подготовить их для коммита. Когда файлы добавляются в индекс, они будут включены в следующий коммит.

Особенности команды **git add**:
1. Вы можете добавить один или несколько файлов, указав их имена после команды `git add` (git add Register.test.tsx)
2. Можно добавить все файлы из текущей директории и ее поддиректорий с помощью команды `git add .` (не реагирует на изменение регистра)
3. Можно добавить вообще все изменения `git add -A`
4. Флаг `-p` позволяет добавлять изменения файла в индекс частями
![image](uploads/c80926dbb6cec216b07dcd45c628edf0/image.png)
![image](uploads/34177cd2560436a56e73ca638301c5fd/image.png)
![image](uploads/7bf5464e3d3e37e2af4d3ae0f595db52/image.png)

5. Если вы хотите добавить файлы, игнорируемые GIT, используйте флаг `-f` (`git add -f file_name`)

### **git commit**

**git commit** - это команда для сохранения изменений в вашем локальном репозитории GIT.

1. Каждый коммит должен отражать единственное логическое изменение.
2. Сообщение коммита должно быть кратким, но информативным и описывать изменения, вносимые данным коммитом.

**Коммит** - это кирпичик определенной задачи, как кроха души, в нём должны быть изменения для определённой задачи, не затрагивая другие. Если вы делали компонент `footer`, то в вашем коммите не должны быть изменения компонента `header`. Такое явление называется **атомарностью**.

_Атомарность в GIT означает, что каждый коммит должен быть независимым и корректным в отдельности. Это означает, что коммит не должен включать изменения, которые не связаны с его сообщением и выполняемой задачей._

**Атомарные** коммиты позволяют реализовать стратегию ветвления и упрощают работу с версиями кода. Кроме того, атомарность позволяет легче отслеживать историю изменений и находить ошибки в коде.

Работа с **git commit**:

1. ```git commit``` - сделать коммит с развернутым описанием
2. ```git commit -m "description"``` -  сделать коммит с описанием в одну строчку
3. ```git commit --amend``` -  откат ссылки коммита с сохранением новых изменений

### **git clone**

**git clone** - это команда для клонирования удаленного репозитория GIT на компьютер. Клонирование позволяет получить копию кода из удаленного репозитория и работать над ним локально.

Основные особенности:

1. `git clone` может быть выполнен с использованием протоколов HTTP, **SSH** или git://, в зависимости от доступности и настроек удаленного репозитория
2. `git clone `может быть копией всего репозитория или только выбранных веток.

### **git remote**

**git remote** - это команда для управления связями между локальным репозиторием и одним или несколькими удаленными репозиториями. Она позволяет просматривать существующие связи, добавлять новые и удалять ненужные.

Главные теги **git remote**:

1. ```git remote -v```: Эта команда выводит список всех удаленных репозиториев и их URL. В выводе также могут быть указаны статусы, такие как `FETCH_HEAD` или `PUSH_HEAD`
    - 	**FETCH_HEAD** - говорит, что это источник для скачивания
    -	**PUSH_HEAD** - говорит, что это место для отправки данных (push)<br/>![image](uploads/4542c46b539b03b18698b7d2900e5d7c/image.png)

2. `git remote add` - Эта команда позволяет добавить новый удаленный репозиторий в локальный репозиторий. Вы можете указать имя для нового удаленного репозитория и его URL.
`git remote add origin_two <Какой-то URL>`
3. `git remote rm` - Эта команда удаляет связь между локальным и удаленным репозиторием. Вы указываете имя удаленного репозитория, который необходимо удалить.
`git remote rm <origin_name>`

### **git push**

**git push** - это команда для отправки локальных изменений в удаленный репозиторий. Она позволяет обновить изменения в удаленном репозитории, чтобы другие пользователи могли видеть эти изменения.

Как правило, перед использованием команды `git push`, необходимо использовать команды `git add` и `git commit`, чтобы добавить и закоммитить изменения в локальном репозитории.

`Git push` имеет несколько параметров, которые могут быть использованы:

1. `git push origin` - эта команда отправляет изменения в удаленный репозиторий с именем "origin".
2. `git push origin <name_branch>` - эта команда отправляет изменения в удаленный репозиторий с именем "origin" в ветку <name_branch>
3. `git push -u origin` - эта команда отправляет изменения в удаленный репозиторий и устанавливает удаленный репозиторий "origin" как основной. Это означает, что при использовании команды GIT push в будущем, необходимо будет указывать только имя ветки.
4. `git push --force` - эта команда принуждает отправку изменений в удаленный репозиторий, даже если есть конфликты с другими коммитами. Это может быть опасно, потому что это может перезаписать существующие изменения в удаленном репозитории.

### **git pull**

**git pull** является командой, которая позволяет синхронизировать изменения в удаленном репозитории с локальным. Команда скачивает новые данные с удаленного репозитория и автоматически сливает их с локальными изменениями. **git pull** имеет несколько параметров, которые влияют на его работу:

1. `git pull [repository] [branch]`  - эта команда скачивает все изменения с удаленного репозитория и автоматически сливает их с текущей веткой локального репозитория.
2. `git pull --no-commit [repository] [branch]` - эта команда скачивает изменения с удаленного репозитория, но не создает автоматически коммит. Вместо этого, она оставляет изменения внутри индекса, позволяя вам проверить и изменить их, прежде чем зафиксировать.

### **git branch**

![image](uploads/3af552f8f6567a44b930635a5c56d74f/image.png)

Когда вы создаете новую ветку с помощью команды `git branch`, создается копия текущей ветки, в которой вы работаете. Вы можете переключаться между ветками с помощью команды `git checkout`. **(про неё написано ниже)**

Например, если вы хотите создать новую ветку "feature" для работы над новой задачей, вы можете использовать команду `git branch feature`. После этого вы можете переключиться на новую ветку, используя команду `git checkout feature`

Кроме того, вы можете использовать команду `git branch -v` для просмотра списка всех веток в вашем проекте

![image](uploads/1ede5f2287749039c9c6a96df527c3d1/image.png)

Если вы хотите удалить ветку, вы можете использовать команду `git branch -d`, за которой следует имя ветки.

**Интересные теги:**

1. `git branch --merged` – показывает объединенные ветки
2. `git branch --no-merged` – показывает не объединенные ветки

### **git checkout**

**git checkout** - это команда, которая используется для переключения между ветками, создания новых веток, перезаписи файлов в рабочей директории и отмены изменений.

Примеры использования команды **git checkout**:

1. Переключение между ветками: `git checkout branch_name`. Эта команда переключает вас на указанную ветку с именем **"branch_name"**
2. Создание новой ветки: `git checkout -b new_branch_name`. Эта команда создает новую ветку с именем **"new_branch_name"** и переключает вас на нее.

### **git merge**

![image](uploads/0836574109e9b6c8d121a6cbdfeac76c/image.png)

**git merge** - это команда, которая позволяет объединить изменения из одной ветки в другую. Она позволяет разработчикам работать над одним и тем же проектом, не мешая друг другу, и затем объединять свои ветки в одну.

Основные теги, которые могут использоваться в **git merge**:

1. `git merge --ff <branch>` - быстрое слияние используется для быстрого объединения веток, когда одна из веток просто продолжается от другой, и нет необходимости создавать новый коммит
![image](uploads/d8c8a6cc8779d1d81e4a33d97ffe348b/image.png)
2. `git merge --no-ff <branch>` - выполняет слияние, создавая новый коммит, даже если возможно быстрое слияние.
3. `git merge --squash <branch>` - В отличие от обычного слияния, которое создает новый коммит, содержащий все изменения из двух сливаемых веток, `--squash` позволяет сливать изменения в один коммит, но не добавлять их в историю ветки. Это может быть полезно, если вы хотите объединить серию коммитов, более понятный коммит, который реализует какую-то особую задачу или функциональность. После слияния со списком изменений, объединенных с помощью опции `--squash`, вы можете создать новый коммит, в котором будут содержаться все изменения.
4. `git merge recursive <branch_1> <branch_2>` - более сложное объединение, когда две ветки имеют общую базовую ветку, и изменения в обеих ветках должны быть объединены.
![image](uploads/af4fbf0b9b776d4800a63e6b00e50f2f/image.png)
5. `git merge --abort`

### **git rebase**

**Перебазирование.** Перемещение коммитов ветки. Представим две ветки: **master** и **test**. **test** ветка была создана на N-ом коммите **master**. При `rebase` коммиты **test** отцепляется от точки расхождения **master** и цепляются в виде копий к последнему коммиту **master** и уже от него будет идти ветка **test**, а также получит изменения из **master**

![image](uploads/ef945758979c0c3be4e8366bae1cc0c0/image.png)

Основные теги, которые могут использоваться в `git rebase`:

1. `git rebase --onto [branch/commit]` - **onto** говорит от какой ветки или коммита делать **rebase**
2. `git rebase --rebase-megres master`: <br/>Представим ситуацию. У нас было две ветки и мы сделали для них merge. После `merge`, в последнем коммите ветки будут ссылки на **ДВУХ** родителей, вместо **одного**, как это было в других коммитах. **Всё потому, что merge объединил две ветки.** Для `rebase` это приличная проблема, если при `rebase` **последним** коммитом **master** будет **merge**, то он попробует сделать перебазирование **ОТ ДВУХ ВЕТОК**, и продублирует последние коммиты чужой ветки в вашу. т.к он не знает что ты нахрен хочешь ;)<br/>И именно для решения данной проблемы сделали --rebase-megres. В таком случае мы говорим гиту, что нужно сделать перебазирование не относительно ветки, а относительно коммита merge
3. `git rebase -i` – открывается редактор для редактирования выполнения следующего `rebase`. Можно изменить порядок коммитов, можно убрать копирование каких-то коммитов, можно добавить какие-то нужные для нас действия **(например редактирование описание)**

**при конфликте rebase:**

1. `git rebase --abort` (с возвратом **HEAD**)
2. `git rebase --skip`
3. `git rebase --quit` (без возврата **HEAD**)
4. `git rebase --continue` (продолжить после конфликта)

**HEAD - курсор в системе GIT**

### **git diff**

Команда **git diff** используется в GIT для сравнения изменений между двумя коммитами, двумя ветками или двумя файлами.

![image](uploads/b87234857b0e20d03733b31db6d38614/image.png)
![image](uploads/56530c9f3fbb2b52e467980fa885ab28/image.png)
![image](uploads/66423e2f974a6377b9050c87e8599f9e/image.png)

Основные теги, которые можно использовать в команде `git diff`:

1. `--cached` - сравнивает изменения между областью индекса и последним коммитом
2. `HEAD` - сравнивает изменения между последним коммитом и рабочей директорией
3. `<commit>` - сравнивает изменения между указанным коммитом и рабочей директорией
4. `<branch>` - сравнивает изменения между указанной веткой и текущей веткой

`git diff master feature` – **diff** сравнит последние коммиты указанных веток. Выводит все отличия

Основные особенности команды `git diff`:

1. выводит различия между файлами в удобном формате
2. позволяет сравнивать изменения между разными коммитами и ветками
3. может использоваться для нахождения ошибок или конфликтов в изменениях

### **git log**

**git log** - это команда, которая отображает историю коммитов в репозитории GIT. Она позволяет просмотреть списки коммитов с информацией о них, таких как авторы, даты, сообщения коммитов и изменения, внесенные в каждом коммите.

![image](uploads/4ffeded95f61d52f3c7291a98009112b/image.png)

Основные теги, используемые в команде `git log`:

1. `--oneline`: выводит каждый коммит в одной строке.
![image](uploads/2436b3c5fe856923c1947e66798cdfd5/image.png)
2. `--graph`: выводит историю коммитов в виде дерева.
![image](uploads/8eac85bf70da5138563c42ea467912e9/image.png)
3. `--author=<имя>`: позволяет фильтровать коммиты по автору.
4. `--since=<дата>`: позволяет фильтровать коммиты, внесенные после указанной даты.
5. `--until=<дата>`: позволяет фильтровать коммиты, внесенные до указанной даты.

Интересные команды:

1. `git log master feature --graph` – покажет дерево веток и коммитов **feature** относительно **master** (даже их примерное ответвление)
2. `git log test ^master` – показать какие нововведения есть в ветке **test**
3. `git log master` – отобразит логи по этой ветке
4. `git log index.html` – покажет в каких коммитах менялся этот фай

Основные особенности команды `git log`:

1. История коммитов отображается в обратном хронологическом порядке, начиная с самого свежего коммита
2. По умолчанию, `git log` отображает информацию о последних 15 коммитах, но можно настроить это значение с помощью параметров командной строки
3. Команда `git log` может быть использована для просмотра истории слияний и отображения конфликтов слияния

### **git stash**

![image](uploads/d58ed1fde0e704819030320a1e3ee087/image.png)

Команда **git stash** используется для временного сохранения изменений, которые еще не готовы к коммиту или не имеют прямого отношения к текущей ветке. **stash** может содержать изменения в рабочей директории так и в индексе, и сохраненные изменения можно применить позже, когда они станут нужны. **Это особенно полезно, когда вы хотите переключиться на другую ветку или выполнить другую задачу, но сохранить свои текущие изменения, которые вы намереваетесь вернуться к позже.**

Основные команды, связанные со **stash**, включают:

1. `git stash save "message"` - сохраняет текущие незакоммиченные изменения в stash с сообщением "message"
2. `git stash list` - показывает список всех сохраненных stash
3. `git stash apply <stash>@{<N>}` - применяет конкретный stash с указанным номером к текущей ветке. Если номер не указан, используется последний stash
4. `git stash drop <stash>@{<N>}` - удаляет указанный stash. Если номер не указан, используется последний stash
5. `git stash pop` - применяет последний стэш и удаляет его из списка stash

Таким образом, stash может быть очень полезным инструментом, который позволяет сохранить временные изменения и переключаться между задачами, не теряя важную рабочую информацию и сохраняя чистую рабочую директорию.

### **git reset**

**git reset** - это команда, которая позволяет вернуть репозиторий к определенному состоянию. Она выполняет несколько разных задач в зависимости от параметров, которые вы передаете.

Одна из главных особенностей команды `git reset` в том, что она изменяет историю коммитов, удаляя коммиты или перемещая ветки.

Существует несколько параметров, которые можно использовать с командой `git reset`. Они включают в себя:

1. **--hard**: этот параметр изменяет файловую систему и индекс, возвращая их к состоянию, которое было на определенном коммите. Он удаляет любые изменения, которые не были зафиксированы в коммитах, которые исключаются из текущей позиции указателя. Это может быть опасно, так как необратимо.<br/>
`git reset --hard [hash_commit]`
2. **--soft**: этот параметр изменяет только указатель на имя текущего ветки, но не модифицирует файловую систему или индекс. Это позволяет вам изменить последний коммит, не удаляя его или любые изменения, связанные с ним.<br/>
`git reset --soft [hash_commit]`
3. **--soft**: этот параметр изменяет только указатель на имя текущего ветки, но не модифицирует файловую систему или индекс. Это позволяет вам изменить последний коммит, не удаляя его или любые изменения, связанные с ним.<br/>
`git reset --soft [hash_commit]`
4. **--mixed**: этот параметр изменяет индекс репозитория, но не изменяет файловую систему. Он позволяет вам изменять последний коммит, выполняя новые коммиты на основе изменений в индексе.<br/>
`git reset --mixed [hash_commit]`
5. **--merge**: этот параметр позволяет фиксировать конфликты при слиянии двух веток вместо того, чтобы просто выбирать изменения из одной из них.<br/>
`git reset --merge [hash_commit]`

Помимо параметров, вы также можете использовать теги в команде `git reset`, чтобы возвращаться к предыдущим версиям вашего проекта. Теги в GIT - это просто имена, связанные с определенными коммитами в вашей истории. Чтобы использовать тег в команде `git reset`, просто укажите его вместо хэша коммита.

### **git revert**

**git revert** в GIT используется для отмены определенных коммитов. Это позволяет сохранить историю изменений, не удаляя их полностью из репозитория. 

Через **reset** мы откатываемся только локально, но что делать, если коммит уже отправлен на сервер? через **reset** не выйдет откатить коммит у других, т.к такой команды нет. Поэтому создан **revert**, он создает новый коммит, в котором отменены действия последнего коммита

`git revert [hash_commit]`

`git revert A..D – сделать revert для коммитов от A до D`

### **git rerere**

**git rerere** - это инструмент, который помогает автоматически разрешать конфликты при слиянии. Имя "**rerere**" расшифровывается как "**reuse recorded resolution**" (переиспользование записанных решений). Когда Git встречает конфликт при слиянии веток, он запоминает решение, которое использовалось для разрешения конфликта, и сохраняет его в специальной базе данных. При последующих конфликтах GIT может автоматически применить ранее записанное решение.

К сожалению или к счастью, это всё что будет написано про **rerere**, т.к **rerere** это обширная тема, да и мало кто воспользуется данным инструментом на этом проекте. Если у вас появится интерес, то можете изучить данный инструмент самостоятельно.
